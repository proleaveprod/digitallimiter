//________________________________________НАСТРОЙКИ_ГРАФИЧЕСКОГО_РЕЖИМА___________________________________________________
//#define GRAPH_DEBUG         //  При раскоментированнии программа переводится в режим графиков, при котором можно получать графики в Arduino IDE, нажав ctrl+shift+L
#define MAX_VOL     100     //  Макс громкость в режиме графиков
#define MIN_VOL     10      //  Мин  громкость в режиме графиков
#define EXP_K       0.01    //  Экспоненциальный коэффициент  (0.0 - 1.0)

//________________________________________ПОСТОЯННЫЕ_ДЛЯ_ИНТЕГРИРОВАНИЯ__________________________________________________
#define INTEGRAL_K    0.05  //  Коэффициент, на который умножается интеграл от сигнала (по сути просто деление на константу, чтобы не возникло переполнения переменной)
#define PERIOD        100   //  Период интегрирования (мкс)
#define DT            5     //  Шаг дискретного интегрирования (мкс)

//________________________________________ПОСТОЯННЫЕ_ДЛЯ_ОТПРАВКИ_ДАННЫХ_ПО_UART_________________________________________
#define UART_INTERVAL 10    //  Интервал между сообщениями о значении громкости, которые передаются компьютеру через UART шину (мс)
#define PARSE_AMOUNT 3      //  Число значений в массиве, которые хотим получить из пакета с настройками 3 шт - maxV, minV и expK
#define INPUT_AMOUNT 20     //  Максимальное количество символов в пакете, который идёт в сериал 

//***********************************************************************************************************************

//_______________________________________ПЕРЕМЕННЫЕ_ДЛЯ_ПАРСЕРА__________________________________________________________
char inputData[INPUT_AMOUNT];  //   Массив входных значений (СИМВОЛЫ)
int intData[PARSE_AMOUNT];     //   Массив численных значений после парсинга
String string_convert;         // Нужно, чтобы вытащить из сообщения int значения maxV,minV,expK
boolean recievedFlag;
boolean getStarted;
byte index;
//______________________________________ВЫТАЩЕННЫЕ_ИЗ_ПАРСЕРА_ПАРАМЕТРЫ_РЕГУЛЯТОРА_______________________________________
int maxVol,minVol;             // Максимальная и минимальная громкость регулятора
float expK;                    // Коэффициент экспоненциального фильтра
int maxSignal=50;              // Максимальный сигнал за время всей работы регулятора. с самого начала меняется в случае появления более высокого по амплитуде сигнала

//______________________________________ПЕРЕМЕННЫЕ_ДЛЯ_ИНТЕГРИРОВАНИЯ____________________________________________________
long S,dS,counter;            // Переменные для вычисления определенного интеграла методом трапеций.
long Signal,FSignal;          // Переменные, в которых будут храниться проинтегрированная "мощность"(громкость) сигнала и отфильтрованная "мощность"(громкость).

//______________________________________ПЕРЕМЕННЫЕ_ДЛЯ_ТАЙМЕРОВ__________________________________________________________                    
long lastTime1,lastTime2;     // Переменные для реализации таймеров запуска функций.  
                              //lastTime1 (мкс) для интегрирования по периоду,
                              //lastTime2 (мс) для отправки по uart сообщений о значении громкости
//***********************************************************************************************************************

void setup() {                // Начало работы устройства
  Serial.begin(9600);         // Открытие COM-порта с частотой баудрейта 9600
  
  pinMode(A0,INPUT);          // Установка пина A0 в режим "вход"  
  
    #ifdef GRAPH_DEBUG          // При раскоментировании GRAPH_DEBUG программа работает в режиме графиков
    Serial.println("signal, filter, maxSignal, volume, realSignal");
    maxVol=MAX_VOL;
    minVol=MIN_VOL;
    expK=EXP_K;
    while(1)toCompute();   
  #endif                       // В случае если GRAPH_DEBUG закоментирован, то программа пропускает все это и работает в стандартном режиме
  
  Serial.print("VOLUME_CONTROL"); //Отправка на компьютер сообщения об успешном открытии COM-порта
  while(1){
    parsing_of_settings();          // Парсинг-прием строки с параметрами $maxV minV expK;
    if(maxVol||minVol||expK)break;  // Если что-то появилось - выходим из парсинга
  }
  delay(500);                   // Задержка в 500 мс для стабильной работы

  // Здесь программа переходит в loop()  - бесконечный цикл
}

void loop() {             
    int data = toCompute();     // Все вычисление происходит в функции toCompute(), которая возвращает уже готовую громкость от minV до maxV
    uart_send(data);            // Функция отправки этой громкости на компьютер
    
}

void uart_send(int data_to_send){     // Отправка числа по uart на компьютер
  
  if(millis()-lastTime2 > UART_INTERVAL){  // Алгоритм, нужный для того, чтобы можно было вызывать Serial.println(...) раз в UART_INTERVAL миллисекунд.
          lastTime2=millis();      
          Serial.println(data_to_send);    // Отправка числа по uart на компьютер
  }
}

int toCompute(){       // Функция получения отфильтрованной оценки громкости 

  // Алгоритм для получения интеграла методом прямоугольника, раз в DT 
  if(micros() - lastTime1 > DT){      // Делаем так,чтобы функция работала каждый шаг DT
      lastTime1=micros();             
      dS = analogRead(A0) * DT * INTEGRAL_K;  // Вычисляем элементарную площадь dS, как DT * значение сигнала. умножаем на INTEGRAL_K чтобы получать более мелкие значения
      S = S + dS;   // Складываем с предыдущей площадью
      counter = counter+1;
    
      if(counter>PERIOD/DT){        // Как только программа прогонит весь PERIOD, мы получим:
          Signal = S;               // Интегрированный сигнал - это как раз оценка громкости 
          FSignal = expRunningAverage(Signal);  // Отфильтруем этот сигнал экспоненциальным фильтром, чтобы не было резких скачков амплитуды
           
          if(FSignal>maxSignal)maxSignal=FSignal;    // Алгоритм для поиска максимального значения функции. С самого начала работы программа увеличивает максимальное значение сигнала, если такое появляется 
           
          int volume = linear_volumeCompute(FSignal); // Вычисляем громкость, которую будем оптравлять на компьютер 
          
          #ifdef GRAPH_DEBUG              // Для режима графиков
              Serial.print(Signal);
              Serial.print(' ');
              Serial.print(FSignal);
              Serial.print(' ');
              Serial.print(maxSignal);
              Serial.print(' ');
              Serial.println(volume);
              Serial.print(' ');
              Serial.println(analogRead(A0));
              
          #endif
          S=0;                  // Сбрасываем переменные
          counter=0;
          return volume;        // Возвращаем уже саму громкость, которую будем отправлять
      } 
  } 
}
int linear_volumeCompute(long input_signal){    // вычисление значения функции y = k*x + b для получения громкости от minV до maxV
  //Serial.println("linear");
  int b   = maxVol;        
  
  float k = minVol-maxVol;  
  k/=maxSignal;

  if(input_signal<maxSignal)return k*input_signal+b;  
  else return minVol;                         // Если сигнал слишком громкий, понижаем его до minV
}
float expRunningAverage(float newVal) {   //Функция экспоненциальной фильтрации для получения более плавной функции оценки громкости
  
  static float filVal = 0;
  filVal += (newVal - filVal) * expK;
  //Serial.print("exp:");Serial.println(filVal);
  return filVal;
}
void parsing_of_settings() {        // Функция получения с компьютера настроек maxV,minV и expK
  while (Serial.available() > 0) {
    char incomingByte = Serial.read();      // обязательно ЧИТАЕМ входящий символ

    if (incomingByte == '$') {              // если это $
      getStarted = true;                    // поднимаем флаг, что можно парсить
    } else if (incomingByte != ';' && getStarted) { // пока это не ;
      // в общем происходит всякая магия, парсинг осуществляется функцией strtok_r
      inputData[index] = incomingByte;
      index++;
      inputData[index] = NULL;
    } else {
      if (getStarted) {
        char *p = inputData;
        char *str;
        index = 0;
        String value = "";
        while ((str = strtok_r(p, " ", & p)) != NULL) {
          string_convert = str;
          intData[index] = string_convert.toInt();
          index++;
        }
        index = 0;
      }
    }
    if (incomingByte == ';') {        // если таки приняли ; - конец парсинга
      getStarted = false;
      recievedFlag = true;
      Serial.print("SETTINGS OK");    // Специальное сообщение для компьютера об успешном парсинге параметров
      delay(300);
      maxVol=intData[0];              //запись их в переменные
      minVol=intData[1];
      expK=intData[2];
      expK=expK/100;                  //это для того,чтобы из int опять перевести в float долю

 
    }
  }
}
